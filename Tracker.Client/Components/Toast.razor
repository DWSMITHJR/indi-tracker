@using Tracker.Shared.Models
@using System.Timers
@using Tracker.Client.Services
@implements IDisposable

<div class="fixed top-4 right-4 z-50 w-80 space-y-2">
    @foreach (var toast in _toasts)
    {
        <div @key="toast.Id" 
             class="relative p-4 pr-10 rounded-md shadow-lg @GetToastBackground(toast.Level) text-white transform transition-all duration-300 ease-in-out @(toast.IsVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-2")"
             @onclick="() => HideToast(toast.Id)">
            
            <!-- Close button -->
            <button class="absolute top-2 right-2 text-white opacity-70 hover:opacity-100 focus:outline-none"
                    @onclick:stopPropagation="() => HideToast(toast.Id)">
                <svg class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                </svg>
            </button>
            
            <!-- Title and message -->
            <h3 class="font-medium text-sm">@toast.Title</h3>
            <p class="text-sm mt-1">@toast.Message</p>
            
            <!-- Progress bar -->
            @if (toast.ShowProgressBar && toast.AutoClose)
            {
                <div class="mt-2 h-1 bg-black bg-opacity-20 rounded-full overflow-hidden">
                    <div class="h-full bg-white bg-opacity-80 transition-all duration-1000 ease-linear" 
                         style="width: @(toast.Progress)%">
                    </div>
                </div>
            }
        </div>
    }
</div>

@code {
    private class ToastWithState : Toast
    {
        public bool IsVisible { get; set; } = true;
        public double Progress { get; set; } = 100;
        public System.Timers.Timer Timer { get; set; }
        public DateTimeOffset HideAt { get; set; }
    }

    [Inject] private IToastService ToastService { get; set; } = null!;

    private readonly List<ToastWithState> _toasts = new();
    private const int ToastDisplayTime = 5000; // 5 seconds

    protected override void OnInitialized()
    {
        ToastService.OnShow += AddToast;
        ToastService.OnHide += RemoveToast;
    }

    private void AddToast(Toast toast)
    {
        var toastWithState = new ToastWithState
        {
            Id = toast.Id,
            Title = toast.Title,
            Message = toast.Message,
            Level = toast.Level,
            AutoClose = toast.AutoClose,
            AutoCloseDelay = toast.AutoCloseDelay,
            ShowProgressBar = toast.ShowProgressBar,
            HideAt = DateTimeOffset.Now.Add(toast.AutoCloseDelay)
        };

        if (toastWithState.AutoClose)
        {
            toastWithState.Timer = new System.Timers.Timer(50); // Update every 50ms for smooth progress bar
            toastWithState.Timer.Elapsed += (sender, args) => UpdateProgress(toastWithState);
            toastWithState.Timer.Start();
        }

        _toasts.Add(toastWithState);
        InvokeAsync(StateHasChanged);
    }

    private void UpdateProgress(ToastWithState toast)
    {
        var timeLeft = toast.HideAt - DateTimeOffset.Now;
        var progress = (timeLeft.TotalMilliseconds / toast.AutoCloseDelay.TotalMilliseconds) * 100;
        
        toast.Progress = Math.Max(0, Math.Min(100, progress));
        
        if (toast.Progress <= 0)
        {
            toast.Timer?.Stop();
            toast.Timer?.Dispose();
            toast.Timer = null;
            
            // Remove the toast after a short delay to allow the animation to complete
            Task.Delay(300).ContinueWith(_ => 
            {
                InvokeAsync(() => RemoveToast(toast.Id));
            });
        }
        else
        {
            InvokeAsync(StateHasChanged);
        }
    }

    private void RemoveToast(Guid toastId)
    {
        var toast = _toasts.FirstOrDefault(t => t.Id == toastId);
        if (toast != null)
        {
            // Start fade out animation
            toast.IsVisible = false;
            
            // Remove from the list after the animation completes
            Task.Delay(300).ContinueWith(_ => 
            {
                InvokeAsync(() => 
                {
                    var toastToRemove = _toasts.FirstOrDefault(t => t.Id == toastId);
                    if (toastToRemove != null)
                    {
                        toastToRemove.Timer?.Stop();
                        toastToRemove.Timer?.Dispose();
                        _toasts.Remove(toastToRemove);
                        StateHasChanged();
                    }
                });
            });
        }
    }

    private void HideToast(Guid toastId)
    {
        ToastService.HideToast(toastId);
    }

    private string GetToastBackground(ToastLevel level)
    {
        return level switch
        {
            ToastLevel.Info => "bg-blue-500",
            ToastLevel.Success => "bg-green-500",
            ToastLevel.Warning => "bg-yellow-500",
            ToastLevel.Error => "bg-red-500",
            _ => "bg-gray-500"
        };
    }

    public void Dispose()
    {
        ToastService.OnShow -= AddToast;
        ToastService.OnHide -= RemoveToast;
        
        foreach (var toast in _toasts)
        {
            toast.Timer?.Dispose();
        }
    }
}
